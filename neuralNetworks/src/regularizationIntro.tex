

\section{Regularization}

Suppose we're training an $L$-layer neural network with dataset $\{(x_j,y_j)\}\subset\R^{\lay{n}{0}}\times\R^{\lay{n}{L}}$ with $N$ examples.  Assuming a generic loss function $\L:\R^{\lay{n}{L}}\times\R^{\lay{n}{L}}\to\R$, then we have our cost function $\J$ defined on our one-parameter families of parameters $w$ and $b$ given by
$$\J(w,b)=\frac{1}{N}\sum_{j=1}^N\L(\lay{a}{L}{_j},y_j).$$
If our model suffers from overfitting the training set, it's reasonable to impose constraints on the parameters $w$ and/or $b$.  That is, define the function
$$R(w)=\frac{\lambda}{2N}\sum_{\ell=1}^L\norm{\lay{w}{\ell}}_F^2,$$
for some $\lambda>0$, where $\norm{\cdot}_F$ represents the Frobenius norm on matrices, and we define the \textit{regularized cost function} $\J^R$ given by
\begin{align*}
	\J^R(w,b)&=\J(w,b)+R(w)\\
	&=\frac{1}{N}\sum_{j=1}^N\L(\lay{a}{L}{_j},y_j)+\frac{\lambda}{2N}\sum_{\ell=1}^L\norm{\lay{w}{\ell}}_F^2.
\end{align*}
Adding such an $R(w)$ to our cost function is known as \textit{$L^2$-regularization}.  We note that by linearity we have the following equalities amongst gradients:
\begin{align*}
	\frac{\partial\J^R}{\partial\lay{b}{\ell}}&=\frac{\partial\J}{\partial\lay{b}{\ell}}
\end{align*}
and
\begin{align*}
	\frac{\partial\J^R}{\partial\lay{w}{\ell}}&=\frac{\partial\J}{\partial\lay{w}{\ell}}+\frac{\lambda}{N}\lay{w}{\ell}.
\end{align*}

The idea behind regularization is that we're now minimizing
$$\min_{w,b}\J^R(w,b)=\min_{w,b}\left\{\J(w,b)+R(w)\right\},$$
and so for suitably chosen $\lambda>0$, it forces $\norm{\lay{w}{\ell}}_F$ to be small, along with minimizing the cost $\J$.  This balancing-act of minimizing the two functions simultaneously helps with overfitting the data.

A typical tuning via regularization would be similar to the following outline:
\begin{enumerate}[i.]
	\item Partition our dataset $\D=\X\cup\mathcal{D}\cup\mathcal{T}$.
	\item Give a set $\Lambda$ of potential regularization parameters.
	\item For each $\lambda\in\Lambda$, we first train on $\X$, that is, we obtain
		\begin{align*}
			(w,b)&=\arg\min_{w,b}\J^R(w,b)\\
			&=\arg\min_{w,b}\left\{\frac{1}{n_X}\sum_{(x,y)\in\X}\L(\lay{a}{L},y)+\frac{\lambda}{2n_X}\sum_{\ell=1}^L\norm{\lay{w}{\ell}}_F^2\right\}
		\end{align*}
		which is dependent on $\lambda$.
	\item Then using the aforementioned $(w,b)=(w,b)(\lambda)$, we evaluate $\mathcal{E}_\lambda(\X)$ and $\mathcal{E}_\lambda(\mathcal{D})$.
	\item After finding $\mathcal{E}_\lambda(\X)$ and $\mathcal{E}_\lambda(\mathcal{D})$ for each $\lambda\in\Lambda$, we choose our desired $\lambda$ and hence our desired parameters $w$ and $b$.
	\item We evaluate our model on $\mathcal{T}$ to determine the overall accuracy.
\end{enumerate}






\subsection{(Inverted) Dropout Regularization}
For illustrative purposes, suppose we have a $2$-layer neural network of the following form:
{\tiny
\begin{equation*}
	\begin{tikzcd}
		{}
		&\R^{\lay{n}{1}\times\lay{n}{0}}
		\arrow[d, swap, "\lay{w}{1}"]
		&\R^{\lay{n}{1}}
		\arrow[d, swap, "\lay{b}{1}"]
		&{}
		&\R^{1\times\lay{n}{1}}
		\arrow[d, swap, "\lay{w}{2}"]
		&\R
		\arrow[d, swap, "\lay{b}{2}"]
		&{}
		&\{0,1\}
		\arrow[d, swap, "y"]
		&{}
		\\
		\R^{\lay{n}{0}}
		\arrow[r, "\lay{a}{0}:=x"]
		&\boxed{\lay{\phi}{1}}
		\arrow[r, "\lay{u}{1}"]
		&\boxed{\lay{\psi}{1}}
		\arrow[r, "\lay{z}{1}"]
		&\boxed{\lay{G}{1}}
		\arrow[r, "\lay{a}{1}"]
		&\boxed{\lay{\phi}{2}}
		\arrow[r, "\lay{u}{2}"]
		&\boxed{\lay{\psi}{2}}
		\arrow[r, "\lay{z}{2}"]
		&\boxed{\lay{G}{2}}
		\arrow[r, "\lay{a}{2}"]
		&\boxed{\L}
		\arrow[r, "\text{loss}"]
		&\R
	\end{tikzcd}
\end{equation*}
}
Let $Q_0, Q_1, Q_2$ denote the collection of all nodes in Layers $0,1,2$, respectively.  Let $p_0, p_1, p_2\in[0,1]$, and define a probability distribution $\P_\ell$ on $Q_\ell$ by
$$\P_\ell(q=1)=p_\ell,\qquad \P_\ell(q=0)=1-p_\ell,$$
where $q=1$ represents the node existing in layer-$\ell$, and $q=0$ represents the dropping of the node from layer-$\ell$.  That is we're effectively reducing the number of nodes throughout the network, thus simplifying the network and reducing the amount of influence of any single feature or node on the entire model.  That is, we would implement a methodology similar to the following:
\begin{enumerate}[i.]
	\item For each iteration, each layer $\ell$ and each training example $x_j$ define the ``dropout vector'' $\lay{D}{\ell}{_j}$ by
	\begin{align*}
		\lay{D}{\ell}{_j}&=\begin{bmatrix}
			d^1_j\\
			\vdots\\
			d^{\lay{n}{\ell}}_j
		\end{bmatrix},
	\end{align*}
	where
	$$d^i_j=\begin{cases}
		1&\text{if }\P(q^i)\leq p_\ell\\
		0&\text{if }\P(q^i)>p_\ell
	\end{cases}.$$
	\item During forward propagation, we redefine
	$$\lay{a}{\ell}\mapsto \frac{\lay{a}{\ell}\odot \lay{D}{\ell}}{p_\ell}.$$
	\item During backward propagation, we define
	$$\lay{\delta}{\ell}\mapsto \frac{\lay{\delta}{\ell}\odot\lay{D}{\ell}}{p_\ell}.$$
	\item Then perform gradient descent, etc with these new values.
\end{enumerate}

\subsubsection{Python Implementation}
We see here the use of inverted dropout regularization in a general neural network.

\lstinputlisting[firstline=1,lastline=238]{src/python/regularization/npDropoutRegularization.py}



\subsection{Data Augmentation}
\TOX{This section requires work.}

There are few other regularization techniques.  One of the simplest techniques is data augmentation, i.e., transforming data you currently have into related but different example to gather a larger dataset (e.g., flipping or distorting images to obtain other relevant images).

\subsection{Early Stopping}
\TOX{This section requires work.}
Another technique is stop the training early (fewer iterations) before the model develops higher variance.

